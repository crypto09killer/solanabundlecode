#!/usr/bin/env python3
import json
import logging
import os
import base58
import requests
import base64
from pathlib import Path
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    Updater,
    CommandHandler,
    MessageHandler,
    Filters,
    ConversationHandler,
    CallbackContext,
    CallbackQueryHandler,
)
from solana.rpc.api import Client
from solana.publickey import PublicKey
from solana.transaction import Transaction, TransactionInstruction
from solana.system_program import transfer, TransferParams
from cryptography.fernet import Fernet
import nacl.signing
import nacl.encoding

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Conversation states
NAME_WALLET, PRIVATE_KEY, BUNDLE_CONFIRM, TOKEN_CONTRACT, RECEIVE_ADDRESS = range(5)
SETTINGS_CHOOSE, SETTINGS_INPUT = range(5, 7)

# File paths
WALLET_FILE = Path("wallets.json")
BUNDLE_FILE = Path("bundle_wallets.json")
SETTINGS_FILE = Path("user_settings.json")

# -------------------------------------------------------------------
# Keypair Class
# -------------------------------------------------------------------
class Keypair:
    def __init__(self, signing_key: nacl.signing.SigningKey):
        self._signing_key = signing_key
        self._verify_key = signing_key.verify_key

    @classmethod
    def generate(cls):
        return cls(nacl.signing.SigningKey.generate())

    @classmethod
    def from_secret_key(cls, secret_key: bytes):
        return cls(nacl.signing.SigningKey(secret_key))

    @property
    def public_key(self) -> str:
        return base58.b58encode(self._verify_key.encode()).decode('utf-8')

    def sign(self, message: bytes) -> bytes:
        return self._signing_key.sign(message).signature

    def __bytes__(self) -> bytes:
        return self._signing_key.encode()

# -------------------------------------------------------------------
# Encryption Setup
# -------------------------------------------------------------------
ENCRYPTION_KEY = os.environ.get('ENCRYPTION_KEY') or Fernet.generate_key()
fernet = Fernet(ENCRYPTION_KEY)

def encrypt_private_key(key_str: str) -> bytes:
    return fernet.encrypt(key_str.encode())

def decrypt_private_key(encrypted_key: bytes) -> str:
    return fernet.decrypt(encrypted_key).decode()

def get_keypair_from_encrypted(encrypted_key: bytes) -> Keypair:
    return Keypair.from_secret_key(base58.b58decode(decrypt_private_key(encrypted_key)))

# -------------------------------------------------------------------
# User Settings Management
# -------------------------------------------------------------------
class UserSettings:
    def __init__(self):
        self.settings = self._load_settings()
    
    def _load_settings(self):
        try:
            if SETTINGS_FILE.exists():
                return json.loads(SETTINGS_FILE.read_text())
        except Exception as e:
            logger.error(f"Settings load error: {e}")
        return {}
    
    def save_settings(self):
        try:
            SETTINGS_FILE.write_text(json.dumps(self.settings, indent=2))
        except Exception as e:
            logger.error(f"Settings save error: {e}")
    
    def get_slippage(self, user_id: int, action: str):
        return self.settings.get(str(user_id), {}).get(f"{action}_slippage", 0.5)
    
    def set_slippage(self, user_id: int, action: str, value: float):
        try:
            user_id = str(user_id)
            value = max(0.1, min(float(value), 100))
            self.settings.setdefault(user_id, {})[f"{action}_slippage"] = value
            self.save_settings()
            return True
        except (ValueError, TypeError):
            return False

user_settings = UserSettings()

# -------------------------------------------------------------------
# Command Handlers
# -------------------------------------------------------------------
def start(update: Update, context: CallbackContext):
    """Handle /start command with private key"""
    if len(context.args) < 1:
        update.message.reply_text("Please provide your private key: /start <private_key>")
        return
    
    try:
        private_key = context.args[0]
        keypair = Keypair.from_secret_key(base58.b58decode(private_key))
        encrypted_key = encrypt_private_key(private_key)
        
        wallet_data = {
            "public_key": keypair.public_key,
            "encrypted_key": encrypted_key.decode(),
            "balance": 0
        }
        
        if WALLET_FILE.exists():
            wallets = json.loads(WALLET_FILE.read_text())
        else:
            wallets = {}
            
        wallets[str(update.message.from_user.id)] = wallet_data
        WALLET_FILE.write_text(json.dumps(wallets, indent=2))
        
        update.message.reply_text(f"Wallet set up successfully!\nPublic Key: {keypair.public_key}")
    except Exception as e:
        logger.error(f"Start error: {e}")
        update.message.reply_text("Invalid private key format")

# ... [Additional command handlers for bundle, distribute, buy, sell, withdraw] ...

# -------------------------------------------------------------------
# Settings Command Handlers
# -------------------------------------------------------------------
def settings_command(update: Update, context: CallbackContext):
    keyboard = [
        [InlineKeyboardButton("Buy Slippage", callback_data='set_buy'),
         InlineKeyboardButton("Sell Slippage", callback_data='set_sell')],
        [InlineKeyboardButton("Cancel", callback_data='cancel')]
    ]
    update.message.reply_text(
        "⚙️ Choose setting to configure:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return SETTINGS_CHOOSE

def settings_choose(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    
    if query.data == 'cancel':
        query.edit_message_text("Settings configuration cancelled.")
        return ConversationHandler.END
    
    action = query.data.replace('set_', '')
    context.user_data['setting_action'] = action
    current = user_settings.get_slippage(query.from_user.id, action)
    
    query.edit_message_text(
        f"Current {action} slippage: {current}%\n"
        f"Enter new {action} slippage (0.1-100):"
    )
    return SETTINGS_INPUT

def settings_input(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    action = context.user_data['setting_action']
    
    try:
        value = float(update.message.text)
        if 0.1 <= value <= 100:
            user_settings.set_slippage(user_id, action, value)
            update.message.reply_text(f"✅ {action.capitalize()} slippage set to {value}%")
        else:
            update.message.reply_text("❌ Value must be between 0.1 and 100")
    except ValueError:
        update.message.reply_text("❌ Please enter a valid number")
    
    return ConversationHandler.END

# -------------------------------------------------------------------
# Main Function
# -------------------------------------------------------------------
def main():
    TOKEN = os.environ.get('TELEGRAM_TOKEN')
    if not TOKEN:
        logger.error("No TELEGRAM_TOKEN environment variable set!")
        return

    updater = Updater(TOKEN)
    dp = updater.dispatcher

    # Add conversation handlers
    dp.add_handler(ConversHandler(
        entry_points=[CommandHandler('settings', settings_command)],
        states={
            SETTINGS_CHOOSE: [CallbackQueryHandler(settings_choose)],
            SETTINGS_INPUT: [MessageHandler(Filters.text & ~Filters.command, settings_input)]
        },
        fallbacks=[CommandHandler('cancel', cancel_settings)],
        allow_reentry=True
    ))

    # Add other command handlers
    dp.add_handler(CommandHandler('start', start))
    # ... Add other command handlers ...

    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()
